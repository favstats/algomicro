<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>Discussion: Licht and Sczepanski (2023)</title>
    <meta charset="utf-8" />
    <meta name="author" content="Comments by: Fabio Votta" />
    <meta name="date" content="2023-04-25" />
    <script src="libs/header-attrs-2.18/header-attrs.js"></script>
    <link href="libs/remark-css-0.0.1/default.css" rel="stylesheet" />
    <link rel="stylesheet" href="ascor.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">
class: bottom, left, title-slide

.title[
# Discussion: Licht and Sczepanski (2023)
]
.subtitle[
## Who are they talking about? Detecting mentions of social groups in political texts with supervised learning
]
.author[
### Comments by: Fabio Votta
]
.date[
### 2023-04-25
]

---


layout: true
    
&lt;div class="logo"&gt;&lt;/div&gt; 





---

class: center, white, middle


# So.. this is a **methods** paper

![](https://media.tenor.com/4g2BkvGurSUAAAAC/think.gif)

![](https://media.tenor.com/Hnp_rv3Zpw8AAAAd/thinking-calculations.gif)

---

### What should a good methods paper include?

.pull-left[

&lt;i&gt;1.&lt;/i&gt; Clearly defined research scope and relevance
+ What methodological gap does the study address?
+ Why is it important to measure/analyze what the study proposes?
{{content}}

]

--
    
&lt;i&gt;2.&lt;/i&gt; Review and compare existing methods
+ Literature review
+ Empirical comparison of measures
+ What is the added value of proposed method?      
{{content}}

--

&lt;i&gt;3.&lt;/i&gt; Detailed documentation of proposed method
+ Explanation of steps
+ Sampling/Annotation strategy
+ Code, including software packages used
+ Easiness to pick up for own use-case, potential pitfalls
{{content}}








---

### What should a good methods paper include?

.pull-left[

&lt;i&gt;1.&lt;/i&gt; Clearly defined research scope and relevance
+ What methodological gap does the study address?
+ Why is it important to measure/analyze what the study proposes?



&lt;i&gt;2.&lt;/i&gt; Review and compare existing methods
+ Literature review
+ Empirical comparison of measures
+ What is the added value of proposed method?   


&lt;i&gt;3.&lt;/i&gt; Detailed documentation of proposed method
+ Explanation of steps
+ Sampling/Annotation strategy
+ Code, including software packages used
+ Easiness to pick up for own use-case, potential pitfalls


]



--

.pull-right[

&lt;i&gt;4.&lt;/i&gt; Validation and Generalizability
+ How did the authors make sure their method does what they say it does?
+ Apply method on case study: 
    + appropriate case selection
    + cases need to be common and/or have potential for generalizability
{{content}}

  
]
  
--
    
&lt;i&gt;5.&lt;/i&gt; Future research agenda(s)
+ What are the limitations of this method?
+ What research does this method enable?
{{content}}

---

### 1. Clearly defined research scope and relevance

+ **Relevance:** "study differences in [whether and] how politicians talk about social groups (e.g., refugees, women, the unemployed, ethnic minorities, etc.)"

+ **Problem:** "a lack of scalable measurement instruments [..] to identify group-based political rhetoric"

+ **Proposal:** The authors propose a **supervised machine learning classifier**
    + fine-tunes pre-trained transformer-based language models (RoBERTa) to identify mentions of (social) groups in political manifestos.
    
--

&lt;br&gt;


+ (Potential) research question(s): 
 
&gt; 1. How can we identify and analyze group mentions in political texts using automated methods?

&gt; 2. How does automated labeling compare to other (traditional) annotation methods (dictionaries/hand-coding)?



---

### 2. Review and compare existing methods

.pull-left[

The authors mainly compare their method to two others:

1. Hand-coded annotation
2. Dictionary (rule-based methods)

+ Results of supervised machine learning is impressive:

&lt;img src="img/coding_acc.png" width = "100%"&gt;


]

--

.pull-right[

+ No empirical comparison of how other methods would perform on the same dataset
    + is this even feasible though?

+ Any additional methods that should be compared or mentioned?
    + named entity recognition, unsupervised learning 
    
+ I am missing a bit of a more systematic comparison of the methods
    + Quality, Scalability, Required Skills


]





---

### 2. Review and compare existing methods

How to identify social group mentions in text and how methods compare:

| Method | Quality | Scalability | (Technical) Skill |
| --- | --- | --- | --- |
| Hand-coded annotation | High (if done correctly) | Low (time-consuming and labor-intensive) | Moderate to high (requires trained annotators) |
| Dictionary-based annotation | Moderate to low (depends on quality of dictionary) | High (relatively fast and easy to implement)  | Low to moderate (requires some technical knowledge but can be done with existing tools or software) |
| Supervised machine learning | High (if properly trained and validated)  | High (scalable to large text corpora)  | High (requires expertise in machine learning, natural language processing, and programming languages such as Python or R)|


---

### 3. Detailed documentation of proposed method

.pull-left[

- The paper provides a clear and concise presentation of the proposed method

&lt;br&gt;

- "Classical" supervised learning paradigm:

![](img/stepwise.png)

&lt;br&gt;

- The authors provide detailed explanations of how they trained their annotators to ensure consistency and accuracy

]


--

.pull-right[

+ Authors settle on using RoBERTa 
    + would there have been other options? would similar transformers perform as well?

+ So far code and software documentation is missing

    + If I want to implement this myself, how do I actually do this? 

]

---

### 4. Validation and Generalizability

.pull-left[
+ How did the authors make sure their method does what they say it does?
    + Cross-validation, out-of-sample predictions

+ Use Case application (UK and Germany):
    + application is rather descriptive
    + maybe: "Embedding Regression: Models for Context-Specific Description and Inference" (Rodriguez/Spirling 2022)

+ Testing cross-party and cross-country/language transfer
    + performance promising but enough?
    
![](img/crossparty.png)
    
]

--
    
.pull-right[

What about temporal aspect:

1. UK data goes from 1964-2019
    + language changes quite a lot in this time
2. Germany data goes from 2002-2021
    + "Menschen mit Migrationshintergund" instead of "Ausl√§nder"
    + gendered languages changes: "Migrant*innen"

    
Question: if you have more recent data, how well can you predict into the past?
    
]


---

### 5.  Future research agenda(s)

.pull-left[

Authors discuss three limitations:

&lt;i&gt;1.&lt;/i&gt; performance on other types of political texts such as parliamentary speeches, legislative documents, or social media posts is *unknown*

&lt;br&gt;

&lt;i&gt;2.&lt;/i&gt; no *typology* of group mentions: e.g. "the working class" or "age-based group".

&lt;br&gt;

&lt;i&gt;3.&lt;/i&gt; dependence on labeled data

]

--

.pull-right[

I would add a fourth one:

&lt;i&gt;4.&lt;/i&gt; necessitates a computational skillset and likely fluency in R/Python



+ What analysis are enabled/enhanced through this method?
    + this could be a bit stronger in the conclusion

]

---

# Additional Questions

1. Computational resources: how long does it take to train the model(s)?


2. You mention that you also train on political groups, institutions, implicit social groups, collective actors. What are the proportions of these? 

---

class: center, middle

# Congratulations to an excellent and informative paper :)



.pull-left[

![](https://c.tenor.com/Q9qk5zN5EesAAAAM/space-kitten.gif)
![](https://c.tenor.com/Q9qk5zN5EesAAAAM/space-kitten.gif)

![](https://c.tenor.com/Q9qk5zN5EesAAAAM/space-kitten.gif)
![](https://c.tenor.com/Q9qk5zN5EesAAAAM/space-kitten.gif)



]

.pull-right[

![](https://c.tenor.com/Q9qk5zN5EesAAAAM/space-kitten.gif)
![](https://c.tenor.com/Q9qk5zN5EesAAAAM/space-kitten.gif)

![](https://c.tenor.com/Q9qk5zN5EesAAAAM/space-kitten.gif)
![](https://c.tenor.com/Q9qk5zN5EesAAAAM/space-kitten.gif)



]




    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"highlightStyle": "github",
"highlightLines": true,
"countIncrementalSlides": false,
"slideNumberFormat": "%current%",
"ratio": "16:9"
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
// add `data-at-shortcutkeys` attribute to <body> to resolve conflicts with JAWS
// screen reader (see PR #262)
(function(d) {
  let res = {};
  d.querySelectorAll('.remark-help-content table tr').forEach(tr => {
    const t = tr.querySelector('td:nth-child(2)').innerText;
    tr.querySelectorAll('td:first-child .key').forEach(key => {
      const k = key.innerText;
      if (/^[a-z]$/.test(k)) res[k] = t;  // must be a single letter (key)
    });
  });
  d.body.setAttribute('data-at-shortcutkeys', JSON.stringify(res));
})(document);
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
